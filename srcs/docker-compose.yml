version: '3.8'

networks:
  transcendence:
    external: false

volumes:
  postgres_data:
  certs:
  esdata01:
  kibanadata:
  metricbeatdata01:
  filebeatdata01:
  logstashdata01:
  vaultdata:
  vault-secret:
  vault-key:
  vault-cert:
  db-secret:
  api-secret:
  nginx-certs:

services:
  db:
    container_name: db
    image: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - db-secret:/root/db
      - vault-cert:/vault-cert
      - ./vault/services/db.sh:/root/db.sh:ro,Z
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "pg_isready"
        ]
      interval: 10s
      timeout: 5s
      retries: 5
    entrypoint: sh /root/db.sh
    depends_on:
      vault:
        condition: service_healthy
    expose:
      - "5432"
    networks:
      - transcendence

  backend:
    container_name: backend
    build:
      context: ./backend
      dockerfile: Dockerfile
    volumes:
      - ./backend:/app
      - api-secret:/home/user/api
      - vault-cert:/vault-cert
      - ./vault/services/api.sh:/home/user/api.sh:ro,Z
    healthcheck:
      test: [
        "CMD", 
        "curl",
        "http://localhost:8000"
      ]
      interval: 10s
      timeout: 10s
      retries: 5
      start_period: 10s
    entrypoint: sh /home/user/api.sh
    depends_on:
      vault:
        condition: service_healthy
      db:
        condition: service_healthy
      redis:
        condition: service_started
    expose:
      - "8000"
    networks:
      - transcendence

  redis:
    container_name: redis
    image: redis:alpine
    networks:
      - transcendence

  frontend:
    container_name: frontend
    build:
      context: ./frontend
      dockerfile: Dockerfile
    expose:
      - "3000"
    networks:
      - transcendence
    volumes:
      - ./frontend/app:/app
      - /app/node_modules
    command: npm start

  nginx:
    container_name: nginx
    build: 
      context: nginx/
      dockerfile: Dockerfile
    ports:
      - "443:443"
      - "80:80"
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./frontend/app/src:/usr/share/nginx/html
      - nginx-certs:/usr/share/nginx/certs
      - ./backend/media:/usr/share/nginx/media
    depends_on:
      backend:
        condition: service_healthy
      frontend:
        condition: service_started
    networks:
      - transcendence

  certs-generator:
    image: alpine
    volumes:
      - nginx-certs:/certs
      - vault-key:/vault-key
      - vault-cert:/vault-cert
      - ./vault/config/openssl.cnf:/openssl.cnf
    command: >
      /bin/sh -c "
      apk add --no-cache openssl &&
      if [ ! -f /certs/nginx.crt ]; then
        openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /certs/nginx.key -out /certs/nginx.crt -subj '/CN=localhost';
      fi;
      if [ ! -f /vault-cert/vault.crt ]; then
        openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 -keyout /vault-key/vault.key -out /vault-cert/vault.crt -config /openssl.cnf -extensions 'v3_req';
      fi;
      "
  # Elasticsearch + Kibana + Logstash + filebeat  (Secure cert)
  # setup:
  #   build:
  #     context: ./elk-b/setup
  #     args:
  #       ELASTIC_VERSION: ${STACK_VERSION}
  #   env_file:
  #     - .env
  #   volumes:
  #     - ./elk-b/setup/entrypoint.sh:/entrypoint.sh:ro,Z
  #     - certs:/usr/share/elasticsearch/config/certs
  #     - ./elk-b/setup/saved_objects.ndjson:/saved_objects.ndjson:ro,Z
  #   user: "0"
  #   healthcheck:
  #     test: [ "CMD-SHELL", "[ -f config/certs/es01/es01.crt ]" ]
  #     interval: 1s
  #     timeout: 5s
  #     retries: 120

  # es01:
  #   container_name: es01
  #   depends_on:
  #     setup:
  #       condition: service_healthy
  #   image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
  #   labels:
  #     co.elastic.logs/module: elasticsearch
  #   volumes:
  #     - certs:/usr/share/elasticsearch/config/certs
  #     - esdata01:/usr/share/elasticsearch/data
  #   ports:
  #     - ${ES_PORT}:9200
  #   environment:
  #     - node.name=es01
  #     - cluster.name=${CLUSTER_NAME}
  #     - discovery.type=single-node
  #     - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
  #     - bootstrap.memory_lock=true
  #     - xpack.security.enabled=true
  #     - xpack.security.http.ssl.enabled=true
  #     - xpack.security.http.ssl.key=certs/es01/es01.key
  #     - xpack.security.http.ssl.certificate=certs/es01/es01.crt
  #     - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
  #     - xpack.security.transport.ssl.enabled=true
  #     - xpack.security.transport.ssl.key=certs/es01/es01.key
  #     - xpack.security.transport.ssl.certificate=certs/es01/es01.crt
  #     - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
  #     - xpack.security.transport.ssl.verification_mode=certificate
  #     - xpack.license.self_generated.type=${LICENSE}
  #   mem_limit: ${ES_MEM_LIMIT}
  #   ulimits:
  #     memlock:
  #       soft: -1
  #       hard: -1
  #   healthcheck:
  #     test:
  #       [
  #         "CMD-SHELL",
  #         "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'"
  #       ]
  #     interval: 10s
  #     timeout: 10s
  #     retries: 120


  # kibana:
  #   container_name: kibana
  #   depends_on:
  #     es01:
  #       condition: service_healthy
  #   image: docker.elastic.co/kibana/kibana:${STACK_VERSION}
  #   labels:
  #     co.elastic.logs/module: kibana
  #   volumes:
  #     - certs:/usr/share/kibana/config/certs
  #     - kibanadata:/usr/share/kibana/data
  #   ports:
  #     - ${KIBANA_PORT}:5601
  #   environment:
  #     - SERVERNAME=kibana
  #     - ELASTICSEARCH_HOSTS=https://es01:9200
  #     - ELASTICSEARCH_USERNAME=kibana_system
  #     - ELASTICSEARCH_PASSWORD=${KIBANA_PASSWORD}
  #     - ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES=config/certs/ca/ca.crt
  #     - XPACK_SECURITY_ENCRYPTIONKEY=${ENCRYPTION_KEY}
  #     - XPACK_ENCRYPTEDSAVEDOBJECTS_ENCRYPTIONKEY=${ENCRYPTION_KEY}
  #     - XPACK_REPORTING_ENCRYPTIONKEY=${ENCRYPTION_KEY}
  #     - SERVER_SSL_ENABLED=true
  #     - SERVER_SSL_KEY=config/certs/kibana/kibana.key
  #     - SERVER_SSL_CERTIFICATE=config/certs/kibana/kibana.crt
  #   mem_limit: ${KB_MEM_LIMIT}
  #   healthcheck:
  #     test:
  #       [
  #         "CMD-SHELL",
  #         "curl -f --cacert config/certs/kibana/kibana.crt https://localhost:5601"
  #       ]
  #     interval: 10s
  #     timeout: 10s
  #     retries: 120


  # metricbeat01:
  #   container_name: metricbeat01
  #   build:
  #     context: ./elk-b/metricbeat
  #     args:
  #       METRICBEAT_VERSION: ${STACK_VERSION}
  #   depends_on:
  #     es01:
  #       condition: service_healthy
  #     kibana:
  #       condition: service_healthy
  #   user: root
  #   volumes:
  #     - certs:/usr/share/metricbeat/certs
  #     - metricbeatdata01:/usr/share/metricbeat/data
  #     - "/var/run/docker.sock:/var/run/docker.sock:ro"
  #     - "/sys/fs/cgroup:/hostfs/sys/fs/cgroup:ro"
  #     - "/proc:/hostfs/proc:ro"
  #     - "/:/hostfs:ro"
  #   environment:
  #     - ELASTIC_USER=elastic
  #     - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
  #     - ELASTIC_HOSTS=https://es01:9200
  #     - KIBANA_HOSTS=https://kibana:5601
  #     - LOGSTASH_HOSTS=http://logstash01:9600

  # filebeat01:
  #   container_name: filebeat01
  #   build:
  #     context: ./elk-b/filebeat
  #     args:
  #       FILEBEAT_VERSION: ${STACK_VERSION}
  #   depends_on:
  #     es01:
  #       condition: service_healthy
  #     kibana:
  #       condition: service_healthy
  #   user: root
  #   volumes:
  #     - certs:/usr/share/filebeat/certs
  #     - filebeatdata01:/usr/share/filebeat/data
  #     - "/var/lib/docker/containers:/var/lib/docker/containers:ro"
  #     - "/var/run/docker.sock:/var/run/docker.sock:ro"
  #   environment:
  #     - LOGSTASH_HOSTS=logstash01:5044

  # logstash01:
  #   container_name: logstash01
  #   depends_on:
  #     es01:
  #       condition: service_healthy
  #     kibana:
  #       condition: service_healthy
  #   image: docker.elastic.co/logstash/logstash:${STACK_VERSION}
  #   labels:
  #     co.elastic.logs/module: logstash
  #   user: root
  #   volumes:
  #     - certs:/usr/share/logstash/certs
  #     - logstashdata01:/usr/share/logstash/data
  #     - ./elk-b/logstash/pipeline:/usr/share/logstash/pipeline
  #     - ./elk-b/logstash/config/logstash.yml:/usr/share/logstash/config/logstash.yml
  #   environment:
  #     - xpack.monitoring.enabled=false
  #     - ELASTIC_USER=elastic
  #     - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
  #     - ELASTIC_HOSTS=https://es01:9200

  vault:
    image: hashicorp/vault:latest
    container_name: vault
    volumes:
      # Vault persistence
      - vaultdata:/vault/file
      - vault-secret:/vault/secrets
      # Vault configuration
      - ./vault/config:/vault/config
      - ./vault/policies:/vault/policies
      - ./vault/tools:/vault/tools
      # Vault entrypoints
      - ./vault/tools/init.sh:/tools/init.sh:ro,Z
      - ./vault/tools/entrypoint.sh:/tools/entrypoint.sh:ro,Z
      - ./vault/tools/wait-certs.sh:/tools/wait-certs.sh:ro,Z
      # Vault certificates
      - vault-key:/vault-key
      - vault-cert:/vault-cert
      # Services tokens
      - db-secret:/vault/secrets/db
      - api-secret:/vault/secrets/api
    healthcheck:
      test: ["CMD", "vault", "status"]
      interval: 30s
      timeout: 10s
      retries: 20
    cap_add:
      - IPC_LOCK
    environment:
      - VAULT_ADDR=https://vault:8200/
      - VAULT_SKIP_VERIFY=true
    # entrypoint: sh /tools/init.sh
    entrypoint: sh /tools/entrypoint.sh
    depends_on:
      - certs-generator
    expose:
      - "8200"
    networks:
      - transcendence
